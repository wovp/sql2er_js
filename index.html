<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>SQL DDL 解析生成图</title>
		<link rel="stylesheet" href="main.css">
		<script src="https://unpkg.com/@antv/g6@5/dist/g6.min.js"></script>
	</head>

	<body>
		<div class="container">
			<h1>SQL DDL 解析生成图</h1>
			<textarea id="ddlInput" placeholder="请输入 SQL DDL 语句"></textarea>
			<button id="parseButton">解析</button>
			<div id="graphContainer" style="width: 1200; height: 800; background-color: aliceblue;"></div>
		</div>
		<script>
			function initDDL() {
				return "-- 创建用户表\n" +
					"CREATE TABLE users (\n" +
					"    user_id INT AUTO_INCREMENT PRIMARY KEY,\n" +
					"    username VARCHAR(50) NOT NULL,\n" +
					"    email VARCHAR(100) UNIQUE NOT NULL\n" +
					");\n" +
					"\n" +
					"-- 创建订单表\n" +
					"CREATE TABLE orders (\n" +
					"    order_id INT AUTO_INCREMENT PRIMARY KEY,\n" +
					"    user_id INT,\n" +
					"    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n" +
					"    FOREIGN KEY (user_id) REFERENCES users(user_id)\n" +
					");";
			}
			document.getElementById('parseButton').addEventListener('click', function() {
				let ddlInput = document.getElementById('ddlInput').value;
				// ddlInput = initDDL();
				const entities = {};
				const relationships = [];
				const allNodes = [];
				const allEdges = [];

				const lines = ddlInput.split('\n');
				let currentTable = null;
				let currentFk = null;

				lines.forEach(line => {
					line = line.trim();
					if (line.startsWith('CREATE TABLE')) {
						currentTable = line.match(/CREATE TABLE (\w+)/)[1];
						entities[currentTable] = {
							columns: []
						};
					} else if (line.includes('PRIMARY KEY')) {
						const match = line.match(/PRIMARY KEY\s*\(([\w,]+)\)/);
						if (match) {
							const primaryKeys = match[1].split(',');
							primaryKeys.forEach(key => {
								entities[currentTable].columns.push({
									name: key.trim(),
									isPrimary: true
								});
							});
						} else {
							// 当 match 没有匹配到的时候，按空格分离提取列名
							const parts = line.split(' ');
							if (parts.length > 0) {
								const columnName = parts[0];
								entities[currentTable].columns.push({
									name: columnName,
									isPrimary: true
								});
							}
						}
					} else if (line.includes('UNIQUE')) {
						const match = line.match(/(\w+)\s+\w+\s+UNIQUE/);
						if (!entities[currentTable].uniqueColumns) {
							entities[currentTable].uniqueColumns = []; // 再次确保 uniqueColumns 数组被初始化
						}
						if (match) {
							entities[currentTable].uniqueColumns.push(match[1].trim());
						}
					} else if (line.includes('FOREIGN KEY')) {
						const fkMatch = line.match(/FOREIGN KEY\s*\((\w+)\)\s+REFERENCES\s+(\w+)\s*\((\w+)\)/);
						if (fkMatch) {
							currentFk = {
								fromTable: currentTable,
								fromColumn: fkMatch[1],
								toTable: fkMatch[2],
								toColumn: fkMatch[3]
							};
						}
					} else if (currentFk) {
						relationships.push(currentFk);
						currentFk = null;
					} else if (currentTable && line.includes(';')) {
						currentTable = null;
					} else if (currentTable) {
						const match = line.match(/(\w+)\s+\w+/);
						if (match) {
							const column = match[1];
							entities[currentTable].columns.push({
								name: column,
								isPrimary: false
							});
						}
					}
				});
				console.log(entities);
				// 生成表节点和属性节点以及它们之间的连线
				for (const table in entities) {
					const tableNode = {
						id: table,
						label: table,
						team: table,
						size: 30,
						type: 'rect' ,// 表节点用矩形表示
						isDia: 0,
					};
					allNodes.push(tableNode);

					entities[table].columns.forEach(column => {
						const columnNode = {
							id: `${table}_${column.name}`,
							label: column.name,
							team: table,
							size: 20,
							type: 'circle' ,// 属性节点用圆形表示
							isDia: 0,
						};
						allNodes.push(columnNode);

						const edge = {
							source: table,
							target: `${table}_${column.name}`,
							label: ''
						};
						allEdges.push(edge);
					});
				}

				// 生成表之间的外键连线
				// relationships.forEach(rel => {
				// 	const edge = {
				// 		source: rel.fromTable,
				// 		target: rel.toTable,
				// 		label: `${rel.fromColumn} -> ${rel.toColumn}`
				// 	};
				// 	allEdges.push(edge);
				// });

				// 生成表之间的关系菱形节点和连线
				console.log(relationships)
				relationships.forEach((rel, index) => {
					let relationType;
					if (Array.isArray(entities[rel.fromTable].uniqueColumns) && entities[rel.fromTable]
						.uniqueColumns.includes(rel.fromColumn)) {
						relationType = '一对一';
					} else {
						relationType = '一对多';
					}

					// 简单判断多对多关系，这里假设存在中间表，中间表有两个外键引用其他表
					const intermediateTables = Object.keys(entities).filter(table => {
						const foreignKeys = relationships.filter(fk => fk.fromTable === table);
						return foreignKeys.length === 2;
					});
					if (intermediateTables.includes(rel.fromTable)) {
						relationType = '多对多';
					}

					const relationNode = {
						id: `relation_${index}`,
						label: relationType,
						type: 'diamond',
						size: 25,
						isDia: 1,
					};
					allNodes.push(relationNode);

					const edge1 = {
						source: rel.fromTable,
						target: `relation_${index}`,
						label: '',
						isDia: 1,
					};
					allEdges.push(edge1);

					const edge2 = {
						source: `relation_${index}`,
						target: rel.toTable,
						label: '',
						isDia: 1,
					};
					allEdges.push(edge2);
				});
				console.log(allEdges)

				const data = {
					nodes: allNodes,
					edges: allEdges
				};
				const graph = new G6.Graph({
					container: 'graphContainer',
					autoFit: 'view',
					data: data,
					node: {
						style: {
							labelText: (d) => d.label,
							labelPlacement: "center",
						},

					},
					edge: {
						label: {
							position: 'center'
						}
					},
					layout: {
						type: 'd3-force',
						link: {
							distance: (d) => {
								// 同一团队内的连接距离更短
								if (d.source.team === d.target.team) return 50;
								
								// 菱形也属于一个团队
								if (d.source.isDia === 1 || d.target.isDia === 1) return 50;
								// 不同团队间的连接距离更长
								return 200;
							},
							strength: (d) => {
								// 同一团队内的连接强度更大
								if (d.source.team === d.target.team) return 0.7;
								if (d.source.isDia === 1 || d.target.isDia === 1) return 0.7;
								// 不同团队间的连接强度更小
								return 0.1;
							},
						},
						// 配置多体力 - 控制节点间的排斥力
						manyBody: {
							strength: (d) => {
								// 团队领导节点（编号1）的排斥力更强
								if (d.label.endsWith('1')) return -100;
								return -30;
							},
						},
						// 配置碰撞力 - 防止节点重叠
						collide: {
							radius: 35,
							strength: 0.8,
						},
						// 配置中心力 - 保持图形在画布中心
						center: {
							strength: 0.05,
						},
					},
					behaviors: ['drag-element-force'],
				});

				graph.render();
			});
		</script>
	</body>

</html>